---
layout: post
title: "Clean Architecture (Chapter 27~) - Robert C. Martin"
author: "Bys"
category: it_book
date: 2022-02-12 01:00:00
tags: reading clean architecture service 
---

### 27. '크고 작은 모든' 서비스들  
서비스 지향 '아키텍처'와 마이크로서비스 '아키텍처'는 최근에 큰 인기를 끌고 있다. 그 이유는 다음과 같다.  

- 서비스를 사용하면 상호 결합이 철저하게 분리되는 것처럼 보인다. 나중에 보겠지만, 이는 일부만 맞는 말이다.  
- 서비스를 사용하면 개발과 배포 독립성을 지원하는 것처럼 보인다. 나중에 보겠지만, 이 역시도 일부만 맞는 말이다.  


**서비스 아키텍처?**  
먼저 서비스를 사용한다는 것이 본질적으로 아키텍처에 해당하는지에 대해 생각해 보자. 이 개념은 명백히 사실이 아니다.  
시스템의 아키텍처는 의존성 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로부터 분리하는 경계에 의해 정의된다.  

단순히 애플리케이션의 행위를 분리할 뿐인 서비스라면 값비싼 함수 호출에 불과하며, 이키텍처 관점에서 꼭 중요하다고 볼 수는 없다.  

모든 서비스가 반드시 아키텍처 관점에서 중요해야만 한다는 뜻은 아니다. 
기능을 프로세스나 플랫폼에 독립적이 되게끔 서비스들을 생성하면 의존성 규칙 준수 여부와 상관없이 큰 도움이 될 때가 많다. 
그러나 서비스 그 자체로는 아키텍처를 정의하지 않는다.  

*모노리틱 시스템이나 컴포넌트 기반 시스템에서 아키텍처를 정의하는 요소는 바로 의존성 규칙을 따르며 아키텍처 경계를 넘나드는 함수 호출들이다.*  
*반면 시스템의 나머지 많은 함수들은 행위를 서로 분리할 뿐이며, 이키텍처적으로는 전혀 중요하지 않다.*  

*서비스도 마찬가지다. 결국 서비스는 프로세스나 플랫폼 경게를 가로지르는 함수 호출에 지나지 않는다.*  
*아키텍처적으로 중요한 서비스도 있지만, 중요하지 않은 서비스도 존재한다. 이 장에서 관심을 가지는 서비스는 전자다.*  

**서비스의 이점?**  

- 결합 분리의 오류  
시스템을 서비스들로 분리함으로써 얻게 되리라 예상되는 큰 이점 하나는 서비스 사이의 결합이 확실히 분리된다는 점이다. 
어쨋든 각 서비스는 서로 다른 프로세스에서, 심지어는 서로 다른 프로세서에서 실행된다. 따라서 서비스는 다른 서비스의 변수에 직접 접근할 수 없다. 
그리고 모든 서비스의 인터페이스는 반드시 잘 정의되어 있어야 한다. 

  이 말에는 어느 정도 일리가 있지만, 꼭 그런 것만은 아니다. 프로세서 내의 또는 네트워크 상의 공유 자원 때문에 결합될 가능성이 여전히 존재한다.  
  더욱이 서로 공유하는 데이터에 의해 이들 서비스는 강력하게 결합되어 버린다. 또한 이 서비스들은 이 필드에 담긴 데이터를 해헉하는 방식을 사전에 완벽하게 조율해야 한다. 

- 개발 및 배포 독립성의 오류  
서비스를 사용함에 따라서 예측되는 또 다른 이점은 전담팀이 서비스를 소유하고 운영한다는 점이다. 
그래서 데브옵스(Devops) 전략의 일환으로 전담팀에서 각 서비스를 작성하고, 유지보수하며, 운영하는 책임을 질 수 있다. 
이러한 개발 및 배포 독립성은 확장 가능한(Scalable)것으로 간주된다. 
대규모 엔터프라이즈 시스템을 독립적으로 개발하고 배포 가능한 수십, 수백, 수천 개의 서비스들을 이용하여 만들 수 있다고 믿는다. 
시스템의 개발, 유지보수, 운영 또한 비슷한 수의 독립적인 팀 단위로 분할할 수 있다고 여긴다.  

  이러한 믿음에도 어느 정도 일리가 있지만, 극히 일부일 뿐이다.  
  첫째로, 대규모 엔터프라이즈 시스템은 서비스 기반 시스템 이외에도, 모노리틱 시스템이나 컴포넌트 기반 시스템으로도 구축할 수 있다는 사실은 증명되어 왔다.  
  서비스는 확장 가능한 시스템을 구축하는 유일한 선택지가 아니다.  

  둘째, '결합 분리의 오류'에 따르면 서비스라고 해서 항상 독립적으로 개발하고, 배포하며, 운영할 수 있는 것은 아니다.  
  데이터나 행위에서 어느 정도 결합되어 있다면 결합된 정도에 맞게 개발, 배포, 운영을 조정해야만 한다.  

`결론`  
서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다. 
시스템의 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다.  

<br><br>

### 28. 테스트 경계  

**시스템 컴포넌트인 테스트**  
테스트는 태생적으로 의존성 규칙을 따른다. 테스트는 세부적이며 구체적인 것으로, 의존성은 항상 테스트 대상이 되는 코드를 향한다. 
실제로 테스트는 아키텍처에서 가장 바깥쪽 원으로 생각할 수 있다. 
시스템 내부의 어떤 것도 테스트에는 의존하지 않으며, 테스트는 시스템의 컴포넌트를 향해, 항상 원의 안쪽으로 의존한다.  

**테스트를 고려한 설계**  
개발자는 종종 테스트가 시스템의 설계 범위 밖에 있다고 여긴다. 이 관점은 치명적이다. 
테스트가 시스템의 설계와 잘 통합되지 않으면, 테스트는 깨지기 쉬워지고, 시스템은 뻣뻣해져서 변경하기가 어려워진다.  

시스템에 가한 간단한 변경이 대량의 테스트 실패로 이어진다는 사실을 알게 되면, 개발자는 그러한 변경을 하지 않으려 들 것이다.  

이 문제를 해결하려면 테스트를 고려해서 설계해야 한다. 소프트웨어 설계의 첫 번째 규칙은 언제나 같다. 
*변동성이 있는 것에 의존하지 말라.* GUI는 변동성이 크다. GUI로 시스템을 조작하는 테스트 스위트는 분명 깨지기 쉽다. 
따라서 시스템과 테스트를 설계할 때, GUI를 사용하지 않고 업무 규칙을 테스트할 수 있게 해야 한다.  

**테스트 API**  
이 목표를 달성하려면 테스트가 모든 업무 규칙을 검증하는 데 사용할 수 있도록 특화된 API를 만들면 된다. 
이러한 API는 보안 제약사항을 무시할 수 있으며, (데이터베이스와 같은) 값 비싼 자원은 건너뛰고, 시스템을 테스트 가능한 특정 상태로 강제하는 강력한 힘을 지녀야만 한다.  

테스트 API는 테스트를 애플리케이션으로부터 분리할 목적으로 사용한다. 
단순히 테스트를 UI에서 분리하는 것만이 아닌, 테스트 구조를 애플리케이션 구조로부터 결합을 분리하는게 목표다.  

**구조적 결합**  
구조적 결합은 테스트 결합 중에서 가장 강하며, 가장 은밀하게 퍼져 나가는 유형이다.  
모든 상용 클래스에 테스트 클래스가 각각 존재하고, 또 모든 상용 메서드에 테스트 메서드 집합이 각각 존재하는 테스트 스위트가 있다고 가정해 보자. 
이러한 테스트 스위트는 애플리케이션 구조에 강하게 결합되어 있다.  

상용 클래스나 메서드 중 하나라도 변경되면 딸려 있는 다수의 테스트가 변경되어야 한다. 
결과적으로 테스트는 깨지기 쉬워지고, 이로 인해 상용 코드를 뻣뻣하게 만든다.  

`결론`  
테스트는 시스템 외부에 있지 않다. 오히려 시스템의 일부다. 
따라서 테스트에서 기대하는 안정성과 회귀의 이점을 얻을 수 있으려면 테스트는 잘 설계 돼야만 한다. 
테스트를 시스틈의 일부로 설계하지 않으면 테스트는 깨지기 쉽고 유지보수하기 어려워지는 경향이 있따. 
이러한 테스트는 유지보수하기가 너무 힘들기 때문에 결국 방바닥의 휴지처럼 버려지는 최후를 맡는다.  


<br><br>

### 29. 클린 임베디드 아키텍처  

더그 슈미트(Doug Schmidt)는 다음과 같이 주장했다.  
> 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어는 낡아 가므로 결국 소프트웨어도 수정해야 한다.  

임베디드 시스템을 조금이라도 개발해 봤다면 하드웨어는 계속해서 발전하고 또 개선된다는 사실을 알고 있을 것이다. 
그와 동시에 '소프트웨어'에는 새로운 기능들이 추가되면서 복잡도가 계속해서 증가한다.  

그래서 더그의 주장에 다음과 같이 덧붙이고자 한다.  
> 소프트웨어는 닳지 않지만, 펌웨어와 하드웨어에 대한 의존성을 관리하지 않으면 안으로부터 파괴될 수 있다.  

잠재적으로 오래 살아남을 수 있던 임베디드 소프트웨어가 하드웨어 의존성에 오염되는 바람에 짧게 삶을 마감하는 일은 드물지 않다.  

**앱-티튜드 테스트(App-titude test)**  
왜 잠재적인 임베디드 소프트웨어는 그렇게도 많이 펌웨어로 변하는가? 
엠베디드 코드가 동작하게 만드는 데 대부분의 노력을 집중하고, 오랫동안 유용하게 남도록 구조화하는 데는 그리 신경 쓰지 않기 때문으로 보인다. 

켄트 백(Kent Beck)은 소프트웨어를 구축하는 세 가지 활동을 다음과 같이 기술했다.
(인용된 문장은 켄트가 한 말이며, 그 옆에 덧붙인 말은 내 해설이다.)

 - "먼저 동작하게 만들어라." 소프트웨어가 동작하지 않는다면 사업은 망한다.  
 - "그리고 올바르게 만들어라." 코드를 리팩터링해서 당신을 포함한 나머지 사람들이 이해할 수 있게 만들고, 요구가 변경되거나 요구를 더 잘 이해하게 되었을 때 코드를 개선할 수 있게 만들어라.  
 - "그리고 빠르게 만들어라." 코드를 리팩터링해서 '요구되는' 성능을 만족시켜라.  

현장에서 지켜본 수많은 임베디드 시스템 소프트웨어는 "동작하게 하라"는 활동만을 염두에 두고 작성된 것처럼 보인다.  

이러한 문제들은 임베디드 소프트웨어만 국한되지 않는다. 
임베디드가 아닌 대다수의 앱들도 코드를 올바르게 작성해서 유효 수명을 길게 늘리는데는 거의관심 없이, 그저 동작하도록 만들어진다.  

앱이 동작하도록 만드는 것을 나는 개발자용 앱-티튜드 테스트(App-titude test)라고 부른다. 
프로그래머가 오직 앱이 동작하도록 만드는 일만 신경 쓴다면 자신의 제품과 고용주에게 몹쓸 짓을 하는 것이다. 
프로그래밍에는 단순히 앱이 동작하도록 만드는 것보다 중요한 것이 훨씬 많다.  

`결론`  
모든 코드가 펌웨어가 되도록 내버려두면 제품이 오래 살아남을 수 없게 된다. 
오직 타깃 하드웨어에서만 테스트할 수 있는 제품도 마찬가지다. 클린 임베디드 아키텍처는 제품이 장기간 생명력을 유지하는 데 도움을 준다.  

<br><br>

## 세부사항  
### 30. 데이터베이스는 세부사항이다  
아키텍처 관점에서 볼 때 데이터베이스는 엔티티가 아니다. 즉, 데이터베이스는 세부사항이라서 아키텍처의 구성요소 수준으로 끌어올릴 수 없다. 
소프트웨어 시스템의 아키텍처와 데이터베이스의 관계를 건물로 비교하면 건물의 아키텍처와 문 손잡이의 관계와 같다.  

데이터베이스는 데이터에 접근할 방법을 제공하는 유틸리티다. 아키텍처 관점에서 보면 이러한 유틸리티는 저수준의 세부사항일 뿐이라서 아키텍처와는 관련이 없다. 
그리고 뛰어난 아키텍트라면 저수준의 메커니즘이 시스템 아키텍처를 오염시키는 일을 용납하지 않는다.  

**관계형 데이터베이스**  
관계형 데이터베이스는 데이터를 저장하고 접근하는 데 탁월한 기술이었다.  

하지만 관계형 데이터베이스의 기술이 얼마나 뛰어나든, 유용하든, 아니면 수핮거으로 견고하든, 결국은 그저 기술일 뿐이다. 
그리고 이는 관계형 데이터베이스가 세부사항임을 뜻한다.  

관계형 테이블은 특정한 형식의 데이터에 접근하는 경우에는 편리하지만, 데이터를 테이블에 행 단위로 배치한다는 자체는 아키텍처적으로 볼 때 전혀 중요하지 않다. 
데이터가 테이블 구조를 가진다는 사실은 오직 아키텍처 외부 원에 위치한 최하위 수준의 유틸리티 함수만 알야아 한다.  

많은 데이터 접근 프레임워크가 테이블과 행이 객체 형태로 시스템 여기저기에서 돌아다니게 허용하는데, 아키텍처적으로 잘못된 설계다. 
이렇게 하면 유스케이스, 업무 규칙, 심지어는 UI조차도 관계형 데이터 구조에 결합되어 버린다.  

**데이터베이스 시스템은 왜 이렇게 널리 사용되는가?**  
오라클, MySQL, SQL 서버가 우위를 차지할 수 있던 이유는 무엇일까? 한마디로 답하자면, 바로 '디스크' 때문이었다.  

디스크에서 데이터는 원형 트랙에 저장된다. 트랙은 섹터로 분할되고, 각 섹터는 사용하기 편한 크기의 바이트를 저장했는데, 대채로 4K였다. 
각 플래터는 대략 수백 개의 트랙으로 구성되었고, 디스크는 십여 개의 플래터로 구성되었다. 
디스크에서 특정 바이트를 읽으려면, 먼저 헤드를 적절한 트랙으로 옮기고, 디스크가 돌면서 헤드 위치에 적절한 섹터가 올 때 까지 기다린 후, 해당 섹터에서 4K 모두를 RAM으로 읽어 들여야 한다. 
그런 후 해당 RAM 버퍼의 색인을 찾아서 필요한 바이트를 가져왔다. 이 모든 작업에는 밀리초 단위의 시간이 걸렸다.  

밀리초가 그리 길지 않다고 느낄 수도 있지만, 대다수의 프로세서에서 한 명령어를 처리하는 주기와 비교해 보면 백만 배나 오래 걸렸다.  

이처럼 디스크 때문에 피해갈 수 없는 시간 지연이라는 점을 완화하기 위해, 색인, 캐시, 쿼리 계획 최적화가 필요해졌다. 
그리고 데이터를 표현하는 일종의 표준적인 방식도 필요했는데, 이러한 색인, 캐시, 쿼리 계획에서 작업 중인 대상이 어떤 데이터인지 알 수 있어야 했기 때문이다. 
시간이 지나면서 이러한 시스템은 뚜렷이 구분되는 두 가지 유형으로 분리되었다. 
하나는 파일 시스템이었고, 다른 하나는 관계형 데이터베이스 관리 시스템(RDBMS)이었다.  

파일 시스템은 문서(Document)기반이다. 파일 시스템은 문서 전체를 자연스럽고 편리하게 저장하는 방법을 제공한다. 
일련의 문서를 이름을 기준으로 저장하거나 조회할 때는 잘 동작하지만, 내용을 기준으로 검색할 때는 그리 크게 도움되지 않는다.  

데이터베이스 시스템은 내용 기반이다. 데이터베이스 시스템은 내용을 기반으로 레코드를 자연스럽고 편리하게 찾는 방법을 제공한다. 
레코드가 서로 공유하는 일부 내용에 기반해서 다수의 레코드를 연관 짓는 데 매우 탁월하다. 
하지만 안타깝게도 정형화되지 않은 문서를 저장하고 검색하는 데는 대체로 부적합하다.  

이들 두 시스템은 데이터를 디스크에 체계화해서, 각 시스템에 특화된 방식으로 접근해야 할 때 가능한 한 효율적으로 데이터를 저장하고 검색할 수 있도록 한다. 
각 시스템은 데이터를 색인하고 배치하는 고유한 전략을 활용한다. 데이터를 빠르게 조작할 수 있도록 결국에는 관련있는 데이터를 RAM으로 가져온다.  

**디스크가 없다면 어떻게 될까?**  
디스크는 RAM으로 대체되고 있다. 디스크가 모두 사라진다면, 그래서 모든 데이터가 RAM에 저장된다면 데이터를 어떻게 체게화할 것인가? 
데이터를 테이블 구조로 만들어 SQL을 이용해 접근할 것인가? 파일 구주로 만들어 디렉터리를 통해 접근할 것인가?  

당연히 아니다. 이 데이터들을 연결 리스트, 트리, 해시 테이블, 스택, 큐 혹은 여타 무수히 맣ㄴ은 데이터 구조로 체계화할 것이며, 데이터에 접근할 때는 포인터나 참조를 사용할 것이다. 
이것이 프로그래머가 하는 일이기 때문이다.  

당신은 이미 이렇게 일하고 있다는 사실을 알아챌 것이다. 데이터가 데이터베이스나 파일 시스템에 있더라도, RAM으로 읽은 후에는 다루기 편리한 형태로 그 구조를 변경한다. 
리스트, 집합, 스택, 큐, 트리 등 입맛에 맞는 임의의 구조로 말이다. 

**세부사항**  
데이터베이스가 세부사항이라고 말하는 이유는 바로 이러한 현실 때문이다. 
데이터베이스는 그저 메커니즘에 불과하며, 디스크 표면과 RAM사이에서 데이터를 이리저리 옮길 때 사용할 뿐이다. 실제로 데이터베이스는 비트를 담는 거대한 그릇이며, 데이터를 장기적으로 저장하는 공간에 지나지 않는다.  

따라서 아키텍처 과넞ㅁ에서 본다면 회전식 자기 디스크에 데이터가 있기만 한다면, 데이터가 어떤 형태인지는 절대로 신경 써서는 안된다. 

**하지만 성능은?**  
데이터 저장소에서 데이터를 빠르게 넣고 뺄 수 있어야 하는 것은 맞지만, 이는 저수준의 관심사다. 
이 관심사는 저수준의 데이터 접근 메커니즘 단에서 다룰 수 있다. 성능은 시스템의 전반적인 아키텍처와는 아무런 관련이 없다.  

`결론`  
체계화된 데이터 구조와 데이터 모델은 아키텍처적으로 중요하다. 
반면, 그저 데이터를 회전식 자기 디스크 표면에서 이리저리 옮길 뿐인 기술과 시스템은 아키텍처적으로 중요치 않다. 
데이터를 테이블 구조로 만들고 SQL로만 접근하도록 하는 관계형 데이터베이스 시스템은 전자보다는 후자와 훨씬 관련이 깊다. 
데이터는 중요하다. 데이터벵시ㅡ는 세부사항이다.  

<br><br>

### 31. 웹은 세부사항이다  
1960년대 이래로 우리 업계는 일련의 반복되는 진동을 겪어왔고, 현재 우베은 그저 이러한 진동의 맨 끝에 있을 뿐이다. 
이 진동은 모든 연산 능력을 중앙 서버에 두는 방식과 모든 연산 능력을 단말에 두는 방식 사이에서 끊임없이 움직여 왔다.  

웹이 유명세를 탄 이래 지난 십여 년 사이에도 우리는 이러한 진동을 수차례 목격했다. 
처음에는 모든 연산 능력이 서버 밤에 위치할 것이고 브라우저는 멍청해질 거라고 생각했다. 그러다가 브라우저에 애플릿(applet)을 추가하기 시작했다. 
하지만 그러다가 다시 이 방식이 내키지 않았기에 동적인 내용은 다시 서버로 이동시켰다. 
하지만 그러다가 다시 이 방식이 마음에 들지 않아서 웹 2.0을 고안했고, Ajax와 자바스크립트를 이용해서 처리 과정의 많은 부분을 다시 브라우저로 옮겼다. 
지금은 거대한 애플리케이션 전부를 브라우저에서 실행되도록 작성할 수 잇는 수준까지 다다랐다. 
그리고 이제 우리 모두는 노드(Node.js)를 이용해 자바스크립트를 다시 서버로 이동시키는 방식에 열광해 있다.  

**끝없이 반복하는 추**  
물론 이처럼 반복되는 진동이 웹으로부터 시작되었다고 보는 일은 옳지 않다.  
앞으로도 우리는 연산 능력을 어디에 둘지 알 수 없을 것이다. 연산 능력을 중앙에 집중하는 방식과 분산하는 방식 사이에서 우리는 끊임없이 움직인다. 

IT 역사 전체로 시야를 넓히면 웹은 아무것도 바꾸지 않았다. 우베은 우리가 발버둥치면서 생기는 여느 수많은 진동 중 하나에 불과하다. 
이 진동은 우리가 태어나기 전에도 있어 왔고, 우리가 은퇴한 뒤에도 지속될 것이다.  
아키텍트로서 우리는 멀리 내다봐야 한다. 이 진동은 그저 핵심 업무 규칙의 중심에서 밀어내고 싶은 단기적인 문제일 뿐이다.  

**요약**  
요약하면 다음과 같다. GUI는 세부사항이다. 웹은 GUI다. 따라서 우베은 세부사항이다. 
그리고 아키텍트라면 이러한 세부사항을 핵심 업무 로직에서 분리된 경계 바깥에 두어야 한다.  

웹이라면 예외가 될 수도 있찌 않을까?  
그 근거로 웹과 같은 GUI는 너무 특이하고 다채롭기 때문에 장치 독립적인 아키텍처를 추구하는 일이 터무니없다고 말할 수도 있다. 
자바스크립트의 유효성 검증이나 드래그-앤-드롭 방식의 AJAX호출, 그리고 웹 페이지에 넣을 수 있는 다른 무수한 위젯과 가젯으로 인한 복잡함을 생각해 볼 때, 웹에서 장치 독립성은 비현실적이라고 주장하기 쉽다.  

이 주장이 어느 정도는 옳다. 애플리케이션과 GUI의 상호작용은 '빈번하며', 또한 이러한 상호작용 방식도 사용 중인 GUI 종류에 따라 차이가 매우 크다. 
브라우저와 웹 애플리케이션이 함께 추는 춤은 데스크톱 GUI와 데스크톱 애플리케이션이 함께 추는 춤과는 차이가 난다. 
이 같은 춤을 추상화하려는 시도는 유닉스로부터 장치를 추상화했던 것과는 달리 성공할 가능성이 없어 보인다.  

하지만 UI와 애플리케이션 사이에는 추상화가 가능한 또 다른 경계가 존재한다.  

완전한 입력 데이터와 그에 따른 출력 데이터는 데이터 구조로 만들어서 유스케이스를 실행하는 처리 과정의 입력 값과 출력 값으로 사용할 수 있다. 
이 방식을 따르면 각 유스케이스가 장치 독립적인 방식으로 UI라는 입출력 장치를 동작시킨다고 간주할 수 있다.  

`결론`  
이러한 종류의 추상화는 만들기 쉽지 않고, 제대로 만들려면 수차례의 반복 과정을 거쳐야 할 것이다. 하지만 가능하다. 
그리고 세상은 마케팅 귀재로 가득하기 때문에 이러한 추상화가 꼭 필요할 때가 많다고 주장하기는 어렵지 않다.  

















<br><br><br>

---

- 출처  
클린 아키텍처 (로버트 C. 마틴)  

---
